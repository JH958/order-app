#커피 주문 앱

## 1. 프로젝트 개요

### 1.1 프로젝트명
커피 주문 앱

### 1.2 프로젝트 목적
사용자가 커피 메뉴를 주문하고, 관리자가 주문을 관리할 수 있는 간단한 풀스택 웹 앱

### 1.3 개발 범위
- 주문하기 화면(메뉴 선택 및 장바구니 기능)
- 관리자 화면(재고 관리 및 주문 상태 관리)
- 데이터를 생성/조회/수정/삭제할 수 있는 기능

## 2. 기술 스택
- 프런트엔드: HTML, CSS, 리액트, 자바스크립트
- 백엔드: Node.js, Express
- 데이터베이스: PostgreSQL

## 3. 기본 사항
- 프런트엔드와 백엔드를 따로 개발
- 기본적인 웹 기술만 사용
- 학습 목적이므로 사용자 인증이나 결제 기능은 제외
- 메뉴는 커피 메뉴만 있음

## 4. 화면 구성 - 주문하기 화면

### 4.1 화면 개요
고객이 커피 메뉴를 선택하고, 옵션을 추가하여 장바구니에 담은 후 주문할 수 있는 메인 화면

### 4.2 헤더 영역
#### 4.2.1 구성 요소
- **로고**: "COZY" 텍스트 로고 (좌측)
- **네비게이션 탭**: 
  - 주문하기 탭 (현재 활성화 상태)
  - 관리자 탭

#### 4.2.2 기능 요구사항
- 관리자 탭 클릭 시 관리자 화면으로 이동
- 주문하기 탭은 현재 활성화 상태 표시
- 헤더는 스크롤 시에도 상단에 고정

### 4.3 메뉴 카드 영역
#### 4.3.1 레이아웃
- 메뉴 카드는 그리드 형태로 배치 (가로 3개 열)
- 카드 간 적절한 간격 유지
- 반응형 레이아웃 (화면 크기에 따라 열 개수 조정)

#### 4.3.2 메뉴 카드 구성 요소
각 메뉴 카드는 다음 요소를 포함:

1. **메뉴 이미지**
   - 메뉴를 대표하는 이미지
   - 이미지가 없는 경우 플레이스홀더 표시
   - 이미지 비율: 16:9 또는 4:3

2. **메뉴 정보**
   - 메뉴명 (예: 아메리카노(ICE), 아메리카노(HOT), 카페라떼)
   - 기본 가격 (예: 4,000원, 5,000원)
   - 간단한 설명 텍스트

3. **옵션 선택**
   - 샷 추가: 체크박스, 추가 금액 표시 (예: +500원)
   - 시럽 추가: 체크박스, 추가 금액 표시 (예: +0원)
   - 선택한 옵션은 체크 표시

4. **담기 버튼**
   - 메뉴와 선택한 옵션을 장바구니에 추가하는 버튼
   - 버튼 텍스트: "담기"

#### 4.3.3 기능 요구사항
- 메뉴 카드는 백엔드 API로부터 메뉴 데이터를 받아 동적으로 생성
- 옵션 체크박스 선택/해제 가능
- "담기" 버튼 클릭 시:
  - 선택한 메뉴와 옵션을 장바구니에 추가
  - 장바구니 영역에 즉시 반영
  - 총 금액 자동 계산 및 업데이트
  - 옵션 체크박스는 초기화

### 4.4 장바구니 영역
#### 4.4.1 구성 요소
1. **장바구니 제목**
   - "장바구니" 텍스트

2. **장바구니 아이템 리스트**
   - 각 아이템 표시 형식: `메뉴명(옵션) X 수량 - 금액원`
   - 예시:
     - 아메리카노(ICE) (샷 추가) X 1 - 4,500원
     - 아메리카노(HOT) X 2 - 8,000원

3. **총 금액 표시**
   - "총 금액" 레이블
   - 총 금액 (예: 12,500원)
   - 강조 표시 (큰 글씨, 굵은 글씨)

4. **주문하기 버튼**
   - 버튼 텍스트: "주문하기"
   - 전체 주문을 완료하는 버튼

#### 4.4.2 기능 요구사항
- 장바구니에 담긴 아이템 실시간 표시
- 같은 메뉴와 옵션 조합이 추가되면 수량 증가
- 총 금액 자동 계산 (메뉴 가격 + 옵션 가격) × 수량의 합계
- "주문하기" 버튼 클릭 시:
  - 장바구니가 비어있으면 경고 메시지 표시
  - 주문 데이터를 백엔드로 전송
  - 주문 완료 시 장바구니 초기화
  - 주문 완료 메시지 표시

#### 4.4.3 레이아웃
- 장바구니 영역은 메뉴 카드 영역 하단에 배치
- 배경색 또는 테두리로 다른 영역과 구분
- 적절한 패딩과 마진 적용

### 4.5 데이터 요구사항

#### 4.5.1 메뉴 데이터
```
메뉴 객체:
- id: 메뉴 고유 ID
- name: 메뉴명
- price: 기본 가격
- description: 메뉴 설명
- image: 이미지 URL (옵셔널)
- options: 옵션 배열
  - name: 옵션명
  - price: 옵션 추가 가격
```

#### 4.5.2 장바구니 데이터
```
장바구니 아이템 객체:
- menuId: 메뉴 ID
- menuName: 메뉴명
- basePrice: 기본 가격
- selectedOptions: 선택한 옵션 배열
  - name: 옵션명
  - price: 옵션 가격
- quantity: 수량
- totalPrice: 총 가격 (기본 가격 + 옵션 가격의 합)
```

#### 4.5.3 주문 데이터
```
주문 객체:
- orderId: 주문 ID (자동 생성)
- items: 장바구니 아이템 배열
- totalAmount: 총 주문 금액
- orderTime: 주문 시간
- status: 주문 상태 (기본값: "대기중")
```

### 4.6 UI/UX 요구사항

#### 4.6.1 스타일링
- 깔끔하고 모던한 디자인
- 일관된 색상 팔레트 사용
- 카드 형태의 메뉴 디자인에 그림자 효과 적용
- 버튼은 명확한 호버/클릭 효과
- 가독성 높은 폰트 사용

#### 4.6.2 반응형 디자인
- 데스크톱: 3열 그리드
- 태블릿: 2열 그리드
- 모바일: 1열 그리드
- 장바구니는 모든 화면 크기에서 잘 보이도록 배치

#### 4.6.3 사용자 피드백
- 담기 버튼 클릭 시 시각적 피드백 (애니메이션 또는 메시지)
- 주문 완료 시 성공 메시지 표시
- 오류 발생 시 명확한 에러 메시지 표시
- 로딩 중일 때 로딩 인디케이터 표시

### 4.7 API 연동

#### 4.7.1 필요한 API 엔드포인트
1. **GET /api/menus**
   - 모든 메뉴 목록 조회
   - 응답: 메뉴 객체 배열

2. **POST /api/orders**
   - 새 주문 생성
   - 요청 바디: 주문 객체
   - 응답: 생성된 주문 정보 (주문 ID 포함)

#### 4.7.2 에러 처리
- 네트워크 오류: "서버와의 연결에 실패했습니다" 메시지
- 주문 실패: "주문 처리 중 오류가 발생했습니다" 메시지
- 메뉴 로딩 실패: "메뉴를 불러올 수 없습니다" 메시지

## 5. 화면 구성 - 관리자 화면

### 5.1 화면 개요
관리자가 재고를 관리하고 주문 상태를 실시간으로 확인 및 업데이트할 수 있는 관리 화면

### 5.2 헤더 영역
#### 5.2.1 구성 요소
- **로고**: "COZY" 텍스트 로고 (좌측)
- **네비게이션 탭**: 
  - 주문하기 탭
  - 관리자 탭 (현재 활성화 상태)

#### 5.2.2 기능 요구사항
- 주문하기 탭 클릭 시 주문하기 화면으로 이동
- 관리자 탭은 현재 활성화 상태 표시
- 헤더는 스크롤 시에도 상단에 고정

### 5.3 관리자 대시보드 영역
#### 5.3.1 구성 요소
대시보드는 주문 통계를 한눈에 보여주는 요약 정보를 제공:

1. **총 주문**: 전체 주문 건수
2. **주문 접수**: 접수 대기 중인 주문 건수
3. **제조 중**: 현재 제조 중인 주문 건수
4. **제조 완료**: 제조가 완료된 주문 건수

#### 5.3.2 표시 형식
- 형식: `항목명 숫자` (예: 총 주문 1 / 주문 접수 1 / 제조 중 0 / 제조 완료 0)
- 슬래시(/)로 구분하여 한 줄에 표시
- 숫자는 실시간으로 업데이트

#### 5.3.3 기능 요구사항
- 페이지 로드 시 최신 통계 데이터 조회
- 주문 상태 변경 시 자동으로 통계 업데이트
- 각 숫자는 동적으로 계산되어 표시

### 5.4 재고 현황 영역
#### 5.4.1 구성 요소
재고 현황 섹션에는 각 메뉴별 재고 카드가 표시됨:

1. **섹션 제목**: "재고 현황"

2. **재고 카드** (각 메뉴별):
   - 메뉴명 (예: 아메리카노 (ICE), 아메리카노 (HOT), 카페라떼)
   - 현재 재고 수량 (예: 10개)
   - 증가(+) 버튼
   - 감소(-) 버튼

#### 5.4.2 레이아웃
- 재고 카드는 가로로 3개씩 그리드 형태로 배치
- 각 카드는 테두리로 구분
- 카드 내에서 메뉴명, 수량, 버튼이 세로로 정렬

#### 5.4.3 기능 요구사항
- **증가(+) 버튼 클릭 시**:
  - 해당 메뉴의 재고 수량 1 증가
  - 백엔드 API로 업데이트 요청
  - 화면에 즉시 반영

- **감소(-) 버튼 클릭 시**:
  - 해당 메뉴의 재고 수량 1 감소
  - 재고가 0개일 경우 더 이상 감소 불가 (버튼 비활성화 또는 경고)
  - 백엔드 API로 업데이트 요청
  - 화면에 즉시 반영

- **재고 표시**:
  - 재고가 0개이면 "품절" 상태 표시 (빨간색 등으로 강조)
  - 재고가 5개 이하이면 "재고 부족" 경고 표시 (노란색 등으로 강조)

### 5.5 주문 현황 영역
#### 5.5.1 구성 요소
주문 현황 섹션에는 모든 주문이 시간순으로 나열됨:

1. **섹션 제목**: "주문 현황"

2. **주문 아이템** (각 주문별):
   - 주문 시간 (예: 7월 31일 13:00)
   - 주문 내역 (예: 아메리카노(ICE) x 1)
   - 주문 금액 (예: 4,000원)
   - 주문 상태 버튼 (예: "주문 접수")

#### 5.5.2 주문 상태
주문은 다음 상태를 가지며, 순차적으로 진행됨:
1. **주문 접수**: 새로 들어온 주문
2. **제조 중**: 제조가 시작된 주문
3. **제조 완료**: 제조가 완료된 주문

#### 5.5.3 레이아웃
- 주문 아이템은 세로로 리스트 형태로 배치
- 각 주문 아이템은 한 행에 모든 정보 표시
- 최신 주문이 상단에 표시 (최근순 정렬)
- 적절한 구분선 또는 배경색으로 각 주문 구분

#### 5.5.4 기능 요구사항
- **주문 상태 버튼 클릭 시**:
  - 현재 상태에서 다음 상태로 변경
  - "주문 접수" → "제조 중" → "제조 완료"
  - 상태 변경 시 버튼 텍스트와 스타일 변경
  - 백엔드 API로 상태 업데이트 요청
  - 대시보드 통계 자동 업데이트

- **주문 리스트**:
  - 페이지 로드 시 모든 주문 조회
  - 새 주문이 들어오면 자동으로 리스트에 추가 (실시간 업데이트 또는 수동 새로고침)
  - 주문 완료 후 일정 시간이 지나면 아카이빙 (옵션)

- **주문 상태별 표시**:
  - "주문 접수": 기본 스타일 (흰색 배경 등)
  - "제조 중": 진행 중 스타일 (파란색 배경 등)
  - "제조 완료": 완료 스타일 (녹색 배경 등)

### 5.6 데이터 요구사항

#### 5.6.1 재고 데이터
```
재고 객체:
- menuId: 메뉴 ID
- menuName: 메뉴명
- stock: 현재 재고 수량
- lowStockThreshold: 재고 부족 기준 (기본값: 5)
```

#### 5.6.2 주문 데이터 (관리자용)
```
주문 객체:
- orderId: 주문 ID
- items: 주문 아이템 배열
  - menuName: 메뉴명
  - quantity: 수량
  - options: 옵션 배열
- totalAmount: 총 금액
- orderTime: 주문 시간
- status: 주문 상태 ("주문 접수", "제조 중", "제조 완료")
```

#### 5.6.3 대시보드 통계 데이터
```
통계 객체:
- totalOrders: 총 주문 건수
- pendingOrders: 주문 접수 건수
- inProgressOrders: 제조 중 건수
- completedOrders: 제조 완료 건수
```

### 5.7 UI/UX 요구사항

#### 5.7.1 스타일링
- 관리자 화면에 적합한 깔끔하고 전문적인 디자인
- 대시보드는 상단에 고정되어 항상 보이도록 배치
- 재고와 주문 영역은 명확하게 구분 (배경색, 테두리 등)
- 버튼은 현재 상태를 명확히 표시하는 색상 사용
- 재고 부족/품절 상태는 시각적으로 명확히 구분

#### 5.7.2 반응형 디자인
- 데스크톱: 재고 카드 3열, 주문 리스트 넓게 표시
- 태블릿: 재고 카드 2열, 주문 리스트 적절히 조정
- 모바일: 재고 카드 1열, 주문 리스트 세로로 스택

#### 5.7.3 사용자 피드백
- 재고 증감 버튼 클릭 시 즉시 반영 및 시각적 피드백
- 주문 상태 변경 시 애니메이션 효과
- 재고가 0이 되면 품절 알림 표시
- 새 주문이 들어오면 알림 표시 (옵션: 사운드, 배지 등)
- 로딩 중일 때 로딩 인디케이터 표시
- 작업 완료 시 성공 메시지 표시

#### 5.7.4 접근성
- 재고 증감 버튼은 터치하기 쉬운 크기로 디자인
- 색상뿐만 아니라 텍스트로도 상태 표시
- 키보드 네비게이션 지원

### 5.8 API 연동

#### 5.8.1 필요한 API 엔드포인트

1. **GET /api/inventory**
   - 모든 메뉴의 재고 정보 조회
   - 응답: 재고 객체 배열

2. **PUT /api/inventory/:menuId**
   - 특정 메뉴의 재고 수량 업데이트
   - 요청 바디: `{ stock: number }`
   - 응답: 업데이트된 재고 정보

3. **GET /api/orders**
   - 모든 주문 목록 조회
   - 쿼리 파라미터 (옵션): `status` (특정 상태의 주문만 조회)
   - 응답: 주문 객체 배열

4. **PUT /api/orders/:orderId/status**
   - 주문 상태 업데이트
   - 요청 바디: `{ status: string }`
   - 응답: 업데이트된 주문 정보

5. **GET /api/dashboard/stats**
   - 대시보드 통계 데이터 조회
   - 응답: 통계 객체

#### 5.8.2 에러 처리
- 네트워크 오류: "서버와의 연결에 실패했습니다" 메시지
- 재고 업데이트 실패: "재고 업데이트 중 오류가 발생했습니다" 메시지
- 주문 조회 실패: "주문 정보를 불러올 수 없습니다" 메시지
- 상태 변경 실패: "주문 상태 변경에 실패했습니다" 메시지
- 유효하지 않은 값: "올바른 값을 입력해주세요" 메시지

#### 5.8.3 실시간 업데이트 (선택 사항)
- WebSocket 또는 Server-Sent Events를 통한 실시간 주문 업데이트
- 새 주문 발생 시 자동으로 화면에 반영
- 폴링(Polling) 방식으로 일정 주기마다 데이터 갱신 (예: 5초마다)

### 5.9 비즈니스 로직

#### 5.9.1 재고 관리
- 주문이 완료되면 자동으로 해당 메뉴의 재고 감소
- 재고가 0인 메뉴는 주문하기 화면에서 주문 불가 처리 (옵션)
- 재고 수량은 0 이하로 내려갈 수 없음

#### 5.9.2 주문 상태 관리
- 주문 상태는 순차적으로만 변경 가능 (역행 불가)
- 제조 완료된 주문은 상태 변경 불가 또는 "배달 완료" 등 추가 상태로 진행
- 각 상태 변경 시 타임스탬프 기록

#### 5.9.3 데이터 검증
- 재고 수량은 음수가 될 수 없음
- 주문 상태는 정의된 값만 허용
- 재고 변경 시 변경 이력 기록 (옵션)

## 6. 백엔드 개발

### 6.1 데이터 모델

#### 6.1.1 Menus (메뉴)
메뉴 정보를 저장하는 테이블

**필드:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT): 메뉴 고유 ID
- `name` (VARCHAR): 커피 메뉴 이름
- `description` (TEXT): 메뉴 설명
- `price` (INTEGER): 기본 가격 (원 단위)
- `image` (VARCHAR, NULLABLE): 이미지 URL (옵셔널)
- `stock` (INTEGER, DEFAULT 0): 재고 수량
- `created_at` (TIMESTAMP): 생성 일시
- `updated_at` (TIMESTAMP): 수정 일시

**제약 조건:**
- `name`: NOT NULL, UNIQUE
- `price`: NOT NULL, >= 0
- `stock`: NOT NULL, >= 0

#### 6.1.2 Options (옵션)
메뉴에 추가할 수 있는 옵션 정보를 저장하는 테이블

**필드:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT): 옵션 고유 ID
- `name` (VARCHAR): 옵션 이름 (예: "샷 추가", "시럽 추가")
- `price` (INTEGER): 옵션 추가 가격 (원 단위)
- `menu_id` (INTEGER, FOREIGN KEY): 연결된 메뉴 ID (Menus 테이블 참조)
- `created_at` (TIMESTAMP): 생성 일시
- `updated_at` (TIMESTAMP): 수정 일시

**제약 조건:**
- `name`: NOT NULL
- `price`: NOT NULL, >= 0
- `menu_id`: NOT NULL, FOREIGN KEY REFERENCES Menus(id) ON DELETE CASCADE

**관계:**
- 하나의 메뉴는 여러 개의 옵션을 가질 수 있음 (1:N 관계)

#### 6.1.3 Orders (주문)
주문 정보를 저장하는 테이블

**필드:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT): 주문 고유 ID
- `order_time` (TIMESTAMP): 주문 일시
- `total_amount` (INTEGER): 총 주문 금액 (원 단위)
- `status` (VARCHAR): 주문 상태 (기본값: "주문 접수")
  - 가능한 값: "주문 접수", "제조 중", "제조 완료", "픽업 완료"
- `created_at` (TIMESTAMP): 생성 일시
- `updated_at` (TIMESTAMP): 수정 일시

**제약 조건:**
- `order_time`: NOT NULL
- `total_amount`: NOT NULL, >= 0
- `status`: NOT NULL, CHECK (status IN ('주문 접수', '제조 중', '제조 완료', '픽업 완료'))

#### 6.1.4 OrderItems (주문 아이템)
주문에 포함된 각 메뉴 아이템 정보를 저장하는 테이블

**필드:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT): 주문 아이템 고유 ID
- `order_id` (INTEGER, FOREIGN KEY): 주문 ID (Orders 테이블 참조)
- `menu_id` (INTEGER, FOREIGN KEY): 메뉴 ID (Menus 테이블 참조)
- `quantity` (INTEGER): 수량
- `item_price` (INTEGER): 아이템 단가 (메뉴 가격 + 옵션 가격의 합)
- `total_price` (INTEGER): 아이템 총 가격 (단가 × 수량)
- `created_at` (TIMESTAMP): 생성 일시

**제약 조건:**
- `order_id`: NOT NULL, FOREIGN KEY REFERENCES Orders(id) ON DELETE CASCADE
- `menu_id`: NOT NULL, FOREIGN KEY REFERENCES Menus(id)
- `quantity`: NOT NULL, > 0
- `item_price`: NOT NULL, >= 0
- `total_price`: NOT NULL, >= 0

**관계:**
- 하나의 주문은 여러 개의 주문 아이템을 가질 수 있음 (1:N 관계)

#### 6.1.5 OrderItemOptions (주문 아이템 옵션)
주문 아이템에 선택된 옵션 정보를 저장하는 테이블

**필드:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT): 주문 아이템 옵션 고유 ID
- `order_item_id` (INTEGER, FOREIGN KEY): 주문 아이템 ID (OrderItems 테이블 참조)
- `option_id` (INTEGER, FOREIGN KEY): 옵션 ID (Options 테이블 참조)
- `option_price` (INTEGER): 옵션 가격 (주문 시점의 가격 저장)
- `created_at` (TIMESTAMP): 생성 일시

**제약 조건:**
- `order_item_id`: NOT NULL, FOREIGN KEY REFERENCES OrderItems(id) ON DELETE CASCADE
- `option_id`: NOT NULL, FOREIGN KEY REFERENCES Options(id)
- `option_price`: NOT NULL, >= 0

**관계:**
- 하나의 주문 아이템은 여러 개의 옵션을 가질 수 있음 (1:N 관계)

### 6.2 사용자 흐름 및 데이터 흐름

#### 6.2.1 메뉴 조회 흐름
1. **프런트엔드 요청**: 주문하기 화면 진입 시 `GET /api/menus` 호출
2. **백엔드 처리**: 
   - 데이터베이스에서 Menus 테이블 조회
   - 각 메뉴에 연결된 Options 테이블 조인하여 조회
   - 재고 수량(stock) 포함하여 응답
3. **프런트엔드 표시**: 
   - 메뉴 카드에 메뉴 정보 표시 (이름, 가격, 설명, 이미지, 옵션)
   - 관리자 화면에 재고 수량 표시

#### 6.2.2 주문 생성 흐름
1. **사용자 액션**: 
   - 주문하기 화면에서 메뉴 선택 및 옵션 선택
   - 장바구니에 아이템 추가
   - "주문하기" 버튼 클릭
2. **프런트엔드 요청**: `POST /api/orders` 호출
   - 요청 바디: 주문 정보 (주문 아이템 배열, 총 금액)
3. **백엔드 처리**:
   - Orders 테이블에 주문 레코드 생성 (status: "주문 접수")
   - OrderItems 테이블에 주문 아이템 레코드들 생성
   - OrderItemOptions 테이블에 선택된 옵션 레코드들 생성
   - 주문된 메뉴의 재고 수량 감소 (Menus 테이블 업데이트)
   - 트랜잭션으로 처리하여 모든 작업이 성공하거나 모두 롤백
4. **응답**: 생성된 주문 정보 반환 (주문 ID 포함)
5. **프런트엔드 처리**: 주문 완료 메시지 표시 및 장바구니 초기화

#### 6.2.3 주문 조회 흐름
1. **프런트엔드 요청**: 관리자 화면 진입 시 `GET /api/orders` 호출
2. **백엔드 처리**:
   - Orders 테이블 조회
   - OrderItems 테이블 조인하여 주문 아이템 정보 포함
   - OrderItemOptions 테이블 조인하여 선택된 옵션 정보 포함
   - Menus 테이블 조인하여 메뉴 정보 포함
   - 최신 주문이 먼저 오도록 정렬 (ORDER BY order_time DESC)
3. **프런트엔드 표시**: 주문 현황에 주문 목록 표시

#### 6.2.4 주문 상태 변경 흐름
1. **사용자 액션**: 관리자가 주문 상태 버튼 클릭
   - "제조 시작" → "제조 중"
   - "제조 중" → "제조 완료"
   - "제조 완료" → "픽업 완료"
2. **프런트엔드 요청**: `PUT /api/orders/:orderId/status` 호출
   - 요청 바디: `{ status: "제조 중" }` (또는 다음 상태)
3. **백엔드 처리**:
   - Orders 테이블에서 해당 주문 조회
   - 주문 상태 검증 (순차적 변경만 허용)
   - 주문 상태 업데이트
   - updated_at 타임스탬프 갱신
4. **응답**: 업데이트된 주문 정보 반환
5. **프런트엔드 처리**: 주문 현황 화면 업데이트

#### 6.2.5 재고 관리 흐름
1. **사용자 액션**: 관리자가 재고 증감 버튼 클릭
2. **프런트엔드 요청**: `PUT /api/inventory/:menuId` 호출
   - 요청 바디: `{ stock: 11 }` (새로운 재고 수량)
3. **백엔드 처리**:
   - Menus 테이블에서 해당 메뉴 조회
   - 재고 수량 검증 (>= 0)
   - 재고 수량 업데이트
   - updated_at 타임스탬프 갱신
4. **응답**: 업데이트된 재고 정보 반환
5. **프런트엔드 처리**: 재고 현황 화면 업데이트

### 6.3 API 설계

#### 6.3.1 메뉴 관련 API

**GET /api/menus**
- **설명**: 모든 메뉴 목록 조회 (옵션 정보 포함)
- **요청**: 없음
- **응답**:
  ```json
  [
    {
      "id": 1,
      "name": "아메리카노(ICE)",
      "description": "시원하고 깔끔한 아이스 아메리카노",
      "price": 4000,
      "image": null,
      "stock": 10,
      "options": [
        {
          "id": 1,
          "name": "샷 추가",
          "price": 500,
          "menu_id": 1
        },
        {
          "id": 2,
          "name": "시럽 추가",
          "price": 0,
          "menu_id": 1
        }
      ]
    }
  ]
  ```
- **에러 처리**:
  - 500: 서버 오류 시 "메뉴를 불러올 수 없습니다" 메시지

#### 6.3.2 주문 관련 API

**POST /api/orders**
- **설명**: 새 주문 생성 및 재고 자동 감소
- **요청 바디**:
  ```json
  {
    "items": [
      {
        "menuId": 1,
        "quantity": 2,
        "selectedOptions": [
          {
            "optionId": 1,
            "name": "샷 추가",
            "price": 500
          }
        ]
      }
    ],
    "totalAmount": 9000
  }
  ```
- **응답**:
  ```json
  {
    "orderId": 1,
    "orderTime": "2024-01-26T21:30:00.000Z",
    "totalAmount": 9000,
    "status": "주문 접수",
    "items": [
      {
        "menuName": "아메리카노(ICE)",
        "quantity": 2,
        "selectedOptions": [
          {
            "name": "샷 추가",
            "price": 500
          }
        ],
        "itemPrice": 4500,
        "totalPrice": 9000
      }
    ]
  }
  ```
- **비즈니스 로직**:
  - 주문 생성 시 해당 메뉴의 재고 자동 감소
  - 재고가 부족한 경우 주문 실패 처리
  - 트랜잭션으로 처리하여 원자성 보장
- **에러 처리**:
  - 400: 잘못된 요청 데이터
  - 409: 재고 부족으로 인한 주문 실패
  - 500: 서버 오류

**GET /api/orders**
- **설명**: 모든 주문 목록 조회 (주문 아이템 및 옵션 정보 포함)
- **쿼리 파라미터** (옵션):
  - `status`: 주문 상태로 필터링 (예: `?status=주문 접수`)
- **응답**:
  ```json
  [
    {
      "orderId": 1,
      "orderTime": "2024-01-26T21:30:00.000Z",
      "totalAmount": 9000,
      "status": "주문 접수",
      "items": [
        {
          "menuName": "아메리카노(ICE)",
          "quantity": 2,
          "selectedOptions": [
            {
              "name": "샷 추가",
              "price": 500
            }
          ],
          "itemPrice": 4500,
          "totalPrice": 9000
        }
      ]
    }
  ]
  ```
- **정렬**: 최신 주문이 먼저 오도록 `ORDER BY order_time DESC`
- **에러 처리**:
  - 500: 서버 오류 시 "주문 정보를 불러올 수 없습니다" 메시지

**GET /api/orders/:orderId**
- **설명**: 특정 주문 정보 조회
- **URL 파라미터**:
  - `orderId`: 주문 ID
- **응답**: GET /api/orders와 동일한 형식 (단일 객체)
- **에러 처리**:
  - 404: 주문을 찾을 수 없음
  - 500: 서버 오류

**PUT /api/orders/:orderId/status**
- **설명**: 주문 상태 업데이트
- **URL 파라미터**:
  - `orderId`: 주문 ID
- **요청 바디**:
  ```json
  {
    "status": "제조 중"
  }
  ```
- **응답**: 업데이트된 주문 정보 (GET /api/orders/:orderId와 동일한 형식)
- **비즈니스 로직**:
  - 주문 상태는 순차적으로만 변경 가능
  - "주문 접수" → "제조 중" → "제조 완료" → "픽업 완료"
  - 역행 불가
- **에러 처리**:
  - 400: 잘못된 상태 값 또는 순차적이지 않은 상태 변경
  - 404: 주문을 찾을 수 없음
  - 500: 서버 오류

#### 6.3.3 재고 관련 API

**GET /api/inventory**
- **설명**: 모든 메뉴의 재고 정보 조회
- **요청**: 없음
- **응답**:
  ```json
  [
    {
      "menuId": 1,
      "menuName": "아메리카노 (ICE)",
      "stock": 10
    },
    {
      "menuId": 2,
      "menuName": "아메리카노 (HOT)",
      "stock": 10
    },
    {
      "menuId": 3,
      "menuName": "카페라떼",
      "stock": 10
    }
  ]
  ```
- **에러 처리**:
  - 500: 서버 오류 시 "재고 정보를 불러올 수 없습니다" 메시지

**PUT /api/inventory/:menuId**
- **설명**: 특정 메뉴의 재고 수량 업데이트
- **URL 파라미터**:
  - `menuId`: 메뉴 ID
- **요청 바디**:
  ```json
  {
    "stock": 11
  }
  ```
- **응답**: 업데이트된 재고 정보
  ```json
  {
    "menuId": 1,
    "menuName": "아메리카노 (ICE)",
    "stock": 11
  }
  ```
- **비즈니스 로직**:
  - 재고 수량은 0 이상이어야 함
  - 음수 값 입력 시 오류 반환
- **에러 처리**:
  - 400: 잘못된 재고 수량 (음수 등)
  - 404: 메뉴를 찾을 수 없음
  - 500: 서버 오류

#### 6.3.4 대시보드 통계 API

**GET /api/dashboard/stats**
- **설명**: 관리자 대시보드 통계 데이터 조회
- **요청**: 없음
- **응답**:
  ```json
  {
    "totalOrders": 10,
    "pendingOrders": 3,
    "inProgressOrders": 2,
    "completedOrders": 5
  }
  ```
- **비즈니스 로직**:
  - Orders 테이블에서 상태별로 그룹화하여 집계
  - 실시간으로 계산
- **에러 처리**:
  - 500: 서버 오류

### 6.4 데이터베이스 스키마 설계

#### 6.4.1 테이블 관계도
```
Menus (1) ──< (N) Options
  │
  │ (1)
  │
  │ (N)
OrderItems ──< (N) OrderItemOptions
  │
  │ (N)
  │
  │ (1)
Orders
```

#### 6.4.2 인덱스 설계
- **Menus 테이블**:
  - `id`: PRIMARY KEY (자동 인덱스)
  - `name`: UNIQUE INDEX (메뉴명 중복 방지)
  
- **Options 테이블**:
  - `id`: PRIMARY KEY (자동 인덱스)
  - `menu_id`: INDEX (메뉴별 옵션 조회 성능 향상)
  
- **Orders 테이블**:
  - `id`: PRIMARY KEY (자동 인덱스)
  - `order_time`: INDEX (시간순 정렬 성능 향상)
  - `status`: INDEX (상태별 필터링 성능 향상)
  
- **OrderItems 테이블**:
  - `id`: PRIMARY KEY (자동 인덱스)
  - `order_id`: INDEX (주문별 아이템 조회 성능 향상)
  - `menu_id`: INDEX (메뉴별 주문 조회 성능 향상)
  
- **OrderItemOptions 테이블**:
  - `id`: PRIMARY KEY (자동 인덱스)
  - `order_item_id`: INDEX (주문 아이템별 옵션 조회 성능 향상)

### 6.5 비즈니스 로직 및 제약 조건

#### 6.5.1 주문 생성 시 재고 관리
- 주문 생성 시 주문된 메뉴의 재고를 자동으로 감소
- 재고가 부족한 경우 주문 실패 처리
- 트랜잭션으로 처리하여 주문 생성과 재고 감소가 원자적으로 처리
- 재고가 0인 메뉴는 주문 불가 (옵션: 프런트엔드에서 주문 버튼 비활성화)

#### 6.5.2 주문 상태 관리
- 주문 상태는 순차적으로만 변경 가능
  - "주문 접수" → "제조 중" → "제조 완료" → "픽업 완료"
- 역행 불가 (예: "제조 중"에서 "주문 접수"로 변경 불가)
- 각 상태 변경 시 `updated_at` 타임스탬프 갱신

#### 6.5.3 데이터 무결성
- 외래 키 제약 조건으로 참조 무결성 보장
- CASCADE DELETE: 주문 삭제 시 관련 주문 아이템 및 옵션도 함께 삭제
- CHECK 제약 조건으로 주문 상태 값 검증
- NOT NULL 제약 조건으로 필수 필드 보장

#### 6.5.4 트랜잭션 처리
- 주문 생성 시 다음 작업들을 하나의 트랜잭션으로 처리:
  1. Orders 테이블에 주문 레코드 삭입
  2. OrderItems 테이블에 주문 아이템 레코드들 삽입
  3. OrderItemOptions 테이블에 옵션 레코드들 삽입
  4. Menus 테이블의 재고 수량 업데이트
- 하나라도 실패하면 전체 롤백

### 6.6 에러 처리 및 검증

#### 6.6.1 입력 데이터 검증
- 주문 생성 시:
  - 메뉴 ID 유효성 검증
  - 수량이 1 이상인지 검증
  - 옵션 ID가 해당 메뉴에 속하는지 검증
  - 총 금액이 올바르게 계산되었는지 검증
- 재고 업데이트 시:
  - 재고 수량이 0 이상인지 검증
- 주문 상태 변경 시:
  - 상태 값이 유효한지 검증
  - 순차적 변경인지 검증

#### 6.6.2 에러 응답 형식
```json
{
  "error": true,
  "message": "에러 메시지",
  "code": "ERROR_CODE"
}
```

#### 6.6.3 HTTP 상태 코드
- **200 OK**: 성공
- **201 Created**: 리소스 생성 성공
- **400 Bad Request**: 잘못된 요청 데이터
- **404 Not Found**: 리소스를 찾을 수 없음
- **409 Conflict**: 재고 부족 등 비즈니스 로직 위반
- **500 Internal Server Error**: 서버 오류

### 6.7 보안 고려사항

#### 6.7.1 입력 데이터 검증
- SQL Injection 방지를 위한 파라미터화된 쿼리 사용
- XSS 방지를 위한 입력 데이터 검증 및 이스케이프 처리

#### 6.7.2 CORS 설정
- 프런트엔드 도메인만 허용하도록 CORS 설정
- 개발 환경과 프로덕션 환경별로 다른 설정

#### 6.7.3 데이터 검증
- 모든 입력 데이터에 대한 유효성 검증
- 타입 검증 및 범위 검증

### 6.8 성능 최적화

#### 6.8.1 데이터베이스 쿼리 최적화
- 필요한 컬럼만 SELECT하여 데이터 전송량 최소화
- JOIN 최적화를 통한 쿼리 성능 향상
- 인덱스를 활용한 조회 성능 향상

#### 6.8.2 캐싱 전략 (선택 사항)
- 메뉴 목록은 자주 변경되지 않으므로 캐싱 고려
- 재고 정보는 실시간성이 중요하므로 캐싱 제한적 사용

#### 6.8.3 페이지네이션 (선택 사항)
- 주문 목록이 많아질 경우를 대비한 페이지네이션 구현
- 기본값: 한 페이지당 20개 주문